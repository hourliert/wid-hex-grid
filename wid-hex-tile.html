<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-image/iron-image.html">
<link rel="import" href="../neon-animation/neon-animation.html">
<link rel="import" href="../neon-animation/neon-animations.html">

<link rel="import" href="d3-import.html">
<link rel="import" href="wid-tiles-store.html">

<dom-module id="wid-hex-tile">
  <style>

    :host {
      display: block;
      cursor: pointer;
      pointer-event
      background-color: transparent;
      opacity: 1;
    }

    #anchor {
      display: none;
    }

    #tile {
      position: relative;
      width: 100%;
      height: 100%;
    }

    #tile ::content a {
      text-decoration: none;
      color: inherit;

      @apply(--layout);
      @apply(--layout-vertical);
      @apply(--layout-center);
    }

    #tile ::content iron-image {
      width: 48px;
      height: 48px;
      position: relative;
    }

    #tile ::content span {
      font-size: 20px;
      position: relative;
    }

  </style>
  <template>
    <wid-tiles-store id="store">
    </wid-tiles-store>

    <div
      id="tile"
      class="layout vertical center-center"
      hidden$="[[_hidden]]">

      <span id="anchor"></span>
      <content select="iron-image"></content>
      <content select="span"></content>
      <content></content>

    </div>

  </template>
</dom-module>

<script>
(function() {

  var NEIGHBOR_DELTAS = [
    [+1, -1, 0], [+1, 0, -1], [0, +1, -1],
    [-1, +1, 0], [-1, 0, +1], [0, -1, +1]
  ];  
   
  Polymer({
    is: 'wid-hex-tile',

    behaviors: [
      Polymer.NeonAnimationRunnerBehavior
    ],

    properties: {
      animationConfig: {
        value: function() {
          return {
            'fade-out': [{
              name: 'fade-out-animation',
              node: this
            }],

            'fade-in': [{
              name: 'fade-in-animation',
              node: this
            }]
          };
        }
      },

      _neighbors: {
        type: Array
      },

      x: {
        type: Number
      },

      y: {
        type: Number
      },

      z: {
        type: Number
      },

      i: {
        type: Number
      },

      j: {
        type: Number
      },

      color: {
        type: String,
        value: '#f0f',
        observer: '_colorChanged'
      },

      width: {
        type: Number,
        value: 150,
        observer: '_widthChanged'
      },

      height: {
        type: Number,
        value: 150,
        observer: '_heightChanged'
      },

      margin: {
        type: Number,
        value: 1
      },

      isSkill: {
        type: Boolean
      },

      marginTop: {
        type: Number,
        observer: '_marginTopChanged'
      },

      isEmpty: {
        type: Boolean,
        value: false
      },

      _SVGHexagonPath: {
        value: Object
      },

      _store: {
        type: Object
      },

      route: {
        type: String
      }
    },

    listeners: {
      tap: '_onTap'
    },

    attached: function() {
      var width = (Math.sqrt(3) / 2) * this.width,
          radius = (this.width + this.height) / 4;

      var svg = d3.select('body').append('svg')
          .remove()
          .attr('width', width)
          .attr('height', this.height)
          .attr('class', 'fit');

      var g = svg.append('g')
          .attr('transform', 'translate(' + width / 2 + ',' + this.height / 2 + ')');

      var hexbin = d3.hexbin()
        .radius(radius);

      g.selectAll('#hexagon')
          .data(hexbin([[0,0]]))
        .enter().append('path')
          .attr('id', 'hexagon')
          .attr('d', hexbin.hexagon(radius - this.margin))
          .style('fill', this.color);

      Polymer.dom(this.$.tile).insertBefore(svg.node(), this.$.anchor);

      //optimization
      this._SVGHexagonPath = this.$$('path');
      this._store = this.$.store;
    },

    /**
     * Get all 6 neighbors.
     * @return {array<Tile>}
     */
    getNeighbors: function () {
      if (!this._neighbors) {
        var store = this._store;
        this._neighbors = NEIGHBOR_DELTAS.map(function (mapping) {
          return store.getTileXYZ(this.x + mapping[0], this.y + mapping[1], this.z + mapping[2]);
        }.bind(this));
      }
      return this._neighbors;
    },

    /**
     * Get a ring of positions given a radius.
     * @param {number} radius - The radius.
     * @return {array<Tile>}
     */
    getRing: function (radius) {
      var store = this._store;

      if (radius <= 0) { return [store.getTileXYZ(this.x, this.y, this.z)]; }

      var currentCubePos = store.getTileXYZ(
        this.x + (NEIGHBOR_DELTAS[4][0] * radius),
        this.y + (NEIGHBOR_DELTAS[4][1] * radius),
        this.z + (NEIGHBOR_DELTAS[4][2] * radius)
      );

      var results = [];
      for (var i = 0; i < 6; i++) {
        for (var j = 0; j < radius; j++) {
          if (!currentCubePos.isEmpty) {
            results.push(currentCubePos);
          }
          currentCubePos = currentCubePos.getNeighbors()[i];
        }
      }

      return results;
    },

    _onTap: function(e) {
      var eventName = (this.isSkill) ? 'tile-skill' : 'tile-empty';

      this.fire(eventName, {
        i: this.i,
        j: this.j,
        tapEvent: e.detail
      });

      if (this.isSkill) {
        page(this.route);
      }
    },

    _widthChanged: function() {
      var width = (Math.sqrt(3) / 2) * this.width;
      this.style.width = isNaN(this.width) ? width : width + 'px';
    },

    _heightChanged: function() {
      this.style.height = isNaN(this.height) ? this.height : this.height + 'px';
    },

    _colorChanged: function() {
      d3.select(this.$.tile).select('g').select('#hexagon').style('fill', this.color);
    },

    _marginTopChanged: function() {
      this.style.marginTop = '-' + this.marginTop + 'px';
    },

    disableLink: function() {
      this.style.pointerEvents = 'none';
      this.style.cursor = 'default';
    },

    enableLink: function() {
      this.style.pointerEvents = 'auto';
      this.style.cursor = 'pointer';
    },

    hide: function () {
      this._hidden = true;
    },

    show: function () {
      this._hidden = false;
    }
  });
})();
</script>